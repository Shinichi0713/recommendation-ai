## 正則行列

線形代数における **「正則（Invertible）」** とは、一言で言えば **「その行列が行う変換を、100%完璧に元に戻せる」** という状態を指します。

数学的な定義と、それが意味する本質的な条件を整理して解説します。

### 1. 数学的な定義

$n$ 次正方行列 $A$ に対して、以下の条件を満たす行列 $B$ が存在するとき、$A$ は**正則である**と言います。

$$AB = BA = I \quad （I は単位行列）$$

このとき、この行列 $B$ を $A$ の **逆行列（Inverse Matrix）** と呼び、$A^{-1}$ と書き表します。

### 2. 正則であるための「3つの言い換え」

「正則かどうか」を判定するための基準はいくつかあり、これらはすべて数学的に同じことを意味しています。

#### ① 行列式が 0 ではない ($|A| \neq 0$)

行列式は、写像によって空間の「面積」や「体積」が何倍になるかを表す指標です。

* **正則:** 体積が維持されている（または変化しているが 0 ではない）。
* **非正則:** 体積が 0 になった（空間がペシャンコに潰れた）。

#### ② ランク（階数）がフルランクである

行列 $A$ のサイズが $n \times n$ のとき、ランクが $n$ である（$rank(A) = n$）ことです。

* これは、行列の各列ベクトルがすべて「独立」しており、情報の欠落がないことを意味します。

#### ③ カーネル（核）がゼロベクトルのみである

$A\mathbf{x} = \mathbf{0}$ となるベクトル $\mathbf{x}$ が、零ベクトル $\mathbf{0}$ しか存在しない状態です。

* もし他のベクトルも $\mathbf{0}$ になってしまうなら、それは「情報を一つに押しつぶして消してしまった」ことになり、元に戻せません。

>__カーネル__  
>行列という写像（加工マシン）に通したときに、 **「ゼロ（原点）に押しつぶされてしまうデータの集まり」** のことを指します。  
>1. 数学的な定義  
>行列 $A$ に対するカーネル（記号では $\text{Ker}(A)$ や $\text{null}(A)$ と書きます）は、次のようなベクトル $\mathbf{x}$ の集合です。  
>$$A\mathbf{x} = \mathbf{0}$$
>つまり、 **「行列 $A$ を掛けると、真っさらなゼロ（零ベクトル）になってしまうような入力 $\mathbf{x}$ はどれか？」**  を探すのがカーネルの定義です。  
>2. 直感的なイメージ：情報の「消滅」  
>写像を「加工」と捉えると、カーネルは **「その加工によって捨てられてしまう情報」** と言い換えることができます。
>- フルランク（正則）な行列の場合:カーネルは零ベクトル $\mathbf{0}$ しかありません。これは「情報を一切捨てずに変換した」ことを意味します。
>- ランクが欠けている行列の場合:特定の方向のベクトルがすべて $0$ に集まってしまいます。例えば、3次元の物体を真上から照らして2次元の「影」を作るとき、 **「高さ方向」の情報はすべて $0$（厚みなし）** になります。この「高さ方向」がカーネルです。
>3. なぜ「核（カーネル）」が重要なのか？  
>カーネルを知ることは、その行列の「弱点」や「隠れた性質」を知ることに繋がります。  
>① 逆行列の存在判定  
>もしカーネルに $\mathbf{0}$ 以外のベクトルが含まれていたら、その行列に逆行列は存在しません。なぜなら、一度 $0$ に潰されてしまった情報は、後から「元々どんな値だったか」を復元することが不可能だからです。
>② 方程式の「自由度」  
>連立一次方程式 $Ax = \mathbf{0}$ を解くことは、まさにカーネルを求める作業そのものです。カーネルが広い（次元が高い）ほど、その方程式には「自由な解（定まらない変数）」がたくさん存在することになります。
>③ データの圧縮  
>画像圧縮などの技術では、あまり重要でない情報をカーネルに近い形（ゼロに近づける）で処理することで、データ量を減らしたりノイズを除去したりします。


### 3. なぜ「正則」という言葉を使うのか？

「正則（Regular）」には「規則正しい、ちゃんとした」という意味があります。

* **正則な行列:** 1つの入力に対して1つの出力が対応し、逆もまた然り。双方向に道が開いている「ちゃんとした」状態。
* **非正則（Singular/特異）な行列:** 複数の入力が1つの点に潰れてしまうなど、数学的に「特殊（異常）な」状態。

### 4. 実務上のメリット

行列が正則であると分かっていると、以下のようなことが可能になります。

1. **方程式が必ず解ける:**  という問題に対し、 という一意の答えが出せます。
2. **基底変換ができる:** 今使っている座標系を、別の都合の良い座標系に「情報を失わずに」履き替えることができます。


__例題__  

正則行列と正則行列ではない行列を用いて、ベクトルを変換させて、変換の結果を可視化しようと思います。

1. 正則な行列

この行列は $x$ 軸方向への「せん断（Shear）」を表しており、行列式が $1$ となるため、空間の面積を保ったまま変形させます。

$$A_{\text{regular}} = \begin{pmatrix}
1 & 0.5 \\
0 & 1
\end{pmatrix}
$$

行列式の計算:

$$\det(A_{\text{regular}}) = (1 \times 1) - (0.5 \times 0) = 1 \neq 0$$

2. 正則ではない行列 (Singular Matrix)
 
この行列は、2行目が1行目の $0.5$ 倍（あるいは1列目が2列目の $0.5$ 倍）という関係になっています。つまり、2つの列ベクトルが同じ直線上に乗ってしまっている状態です。

$$A_{\text{singular}} = \begin{pmatrix}
1 & 2 \\
0.5 & 1
\end{pmatrix}
$$

行列式の計算:

$$\det(A_{\text{singular}}) = (1 \times 1) - (2 \times 0.5) = 1 - 1 = 0$$

上記を可視化するPythonコードは以下です。
コードを実行してみてください。

```python
import numpy as np
import matplotlib.pyplot as plt

def plot_transform(matrix, title, ax):
    # 格子点（ベクトルのかたまり）を作成
    x, y = np.meshgrid(np.linspace(-1, 1, 11), np.linspace(-1, 1, 11))
    pts = np.vstack([x.flatten(), y.flatten()])
    
    # 行列による変換（写像）を実行： Y = A @ X
    transformed_pts = matrix @ pts
    
    # 描画
    ax.scatter(pts[0], pts[1], c='gray', alpha=0.3, s=10, label='Original')
    ax.scatter(transformed_pts[0], transformed_pts[1], c='blue', s=15, label='Transformed')
    
    # 基底ベクトルの行き先を矢印で表示
    v_x = matrix @ np.array([1, 0])
    v_y = matrix @ np.array([0, 1])
    ax.quiver(0, 0, v_x[0], v_x[1], color='red', angles='xy', scale_units='xy', scale=1, label='Basis X')
    ax.quiver(0, 0, v_y[0], v_y[1], color='green', angles='xy', scale_units='xy', scale=1, label='Basis Y')
    
    ax.set_xlim(-2.5, 2.5); ax.set_ylim(-2.5, 2.5)
    ax.axhline(0, color='black', lw=1); ax.axvline(0, color='black', lw=1)
    ax.set_title(title)
    ax.legend()
    ax.grid(True)

# 1. 正則な行列（回転と拡大）
# 行列式 det(A) = 1*1 - 0.5*0 = 1 (0ではない)
A_regular = np.array([[1, 0.5], 
                      [0, 1]])

# 2. 正則ではない行列（一方の次元へ押しつぶす）
# 行列式 det(A) = 1*1 - 1*1 = 0 (空間が潰れる)
A_singular = np.array([[1, 1], 
                       [1, 1]])

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
plot_transform(A_regular, "Regular Matrix (Invertible)\nSpace is preserved", ax1)
plot_transform(A_singular, "Singular Matrix (Non-invertible)\nSpace collapses to a line", ax2)
plt.show()
```

__結果__

実行するとそれぞれ以下のような図が得られます。

<img src="image/5_invertible/1771633295539.png" width="500" style="display: block; margin: 0 auto;">

左側：正則な行列 (Invertible)

- 様子: 元の正方形の格子が、平行四辺形のように「歪んで」はいますが、面としての広がりを保っています。
- 数学的意味: 行列式が $0$ ではないため、青い点を逆行列で計算すれば、元のグレーの点の位置を完全に特定（復元）できます。
- カーネル: カーネルは原点 $(0,0)$ のみです。

右側：正則ではない行列 (Singular)
- 様子: すべての点が 「一直線の上」 に重なってしまいました。2次元あった情報が1次元に「潰された」状態です。
- 数学的意味: 行列式が $0$ です。この直線上の「青い点」が、元々「グレーのどの点」だったのかを特定することは不可能です（情報が失われたため）。
- カーネル: この直線に対して垂直方向に並んでいた点たちが、すべて原点に集められています。その「潰された方向」がこの行列のカーネルです。

