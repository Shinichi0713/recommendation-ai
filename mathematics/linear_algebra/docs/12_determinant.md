
## 行列式

**行列式（Determinant）** とは、一言で言えば **「その行列が、空間を何倍に膨らませたか（あるいは押しつぶしたか）を表す拡大率」** のことです。

行列が「空間を動かす指示書」なら、行列式はその結果として **「どれくらい面積や体積が変化したか」** というスコアのようなものです。通常、行列  に対して  や  と表記されます。

### 1. 幾何学的な意味：面積と体積の拡大率

2次元空間で考えると、行列式の意味が非常にクリアになります。

* **2次元の場合：** 標準基底が作る「面積 1 の正方形」が、行列 $A$ によって変形された後の「平行四辺形の面積」が行列式です。
* **3次元の場合：** 「体積 1 の立方体」が変形された後の「平行六面体の体積」が行列式です。

### 2. 行列式の「値」が教えてくれること

行列式の値を見るだけで、その線形写像が空間に何をしたのかがわかります。

| 行列式の値 | 空間に起きたこと | 数学的な意味 |
| --- | --- | --- |
| $\det(A) = 2$ | 面積が 2 倍に膨らんだ。 | 通常の変換。 |
| $\det(A) = 1$ | 面積は変わらない（回転など）。 | **ユニタリ行列**などがこれに当たる。 |
| $\det(A) = -1$ | 面積は同じだが、**「裏返し」**になった。 | 鏡映（リフレクション）など。 |
| $\det(A) = 0$ | 空間が**ペシャンコに潰れた**。 | **逆行列が存在しない**（正則でない）。 |


### 3. なぜ行列式が重要なのか？（実用的な視点）

__① 逆行列の存在チェック__

行列式が $0$ ということは、2次元の平面を1次元の「線」に、あるいは0次元の「点」に押しつぶしてしまったことを意味します。潰れたものを元の広さに戻す（逆再生する）ことは不可能なため、 **「$\det(A) = 0 \iff$ 逆行列が存在しない」** という非常に重要な判定基準になります。

__② 連立方程式の解__

連立方程式（Systems of linear equations）を解く際、行列式が $0$ でなければ、解が一意に定まります。
これを利用したのが後ほど扱う「クラメルの公式」です。

__③ 多変数関数の積分（ヤコビアン）__

積分で変数を変換する際（例えば直交座標から極座標へ）、微小な領域がどれくらい歪んだかを補正する必要があります。この補正係数として「ヤコビ行列式（ヤコビアン）」が登場します。

### 4. 計算のイメージ（2次の場合）

$$A = \begin{pmatrix} a & b \\ c & d \end{pmatrix}$$

このとき、$\det(A) = ad - bc$ と計算されます。これは、ベクトル $\begin{pmatrix} a \\ c \end{pmatrix}$ と $\begin{pmatrix} b \\ d \end{pmatrix}$ が作る平行四辺形の面積を求めていることに他なりません。


__例題:__ ベクトルと逆行列

行列式が $0$ に近づくにつれて、 **「2次元の面積を持っていた世界が、1次元の『線』へとペシャンコに押しつぶされていく」** 様子を可視化します。

```python
import numpy as np
import matplotlib.pyplot as plt

def simulate_collapsing_space(steps=5):
    # 1. 元の基底ベクトル
    e1 = np.array([1, 0])
    e2_start = np.array([0, 1])  # 最初は直交（行列式=1）
    e2_end = np.array([1, 0])    # 最後はe1と同じ（行列式=0、空間が潰れる）

    # グリッド描画用のデータ
    x = np.linspace(-1, 1, 5)
    y = np.linspace(-1, 1, 5)
    X, Y = np.meshgrid(x, y)
    pts = np.vstack([X.flatten(), Y.flatten()])

    fig, axes = plt.subplots(1, steps, figsize=(20, 4))
    
    for i, t in enumerate(np.linspace(0, 1, steps)):
        # e2 を徐々に e1 に近づける
        e2_current = (1 - t) * e2_start + t * e2_end
        
        # 写像行列 A = [e1, e2_current]
        A = np.column_stack([e1, e2_current])
        det = np.linalg.det(A)
        
        # 空間の変形
        t_pts = A @ pts
        TX = t_pts[0, :].reshape(X.shape)
        TY = t_pts[1, :].reshape(Y.shape)
        
        # 描画
        ax = axes[i]
        # 変形後のグリッド
        for j in range(len(x)):
            ax.plot(TX[j, :], TY[j, :], color='gray', alpha=0.3)
            ax.plot(TX[:, j], TY[:, j], color='gray', alpha=0.3)
        
        # ベクトルの描画（複数のベクトルが潰れていく様子）
        ax.quiver(0, 0, A[0,0], A[1,0], color='red', angles='xy', scale_units='xy', scale=1, label='v1')
        ax.quiver(0, 0, A[0,1], A[1,1], color='blue', angles='xy', scale_units='xy', scale=1, label='v2')
        
        # 設定
        ax.set_xlim(-1.5, 1.5); ax.set_ylim(-1.5, 1.5)
        ax.set_aspect('equal')
        ax.set_title(f"Det = {det:.2f}")
        if i == 0: ax.legend()

    plt.suptitle("Space collapsing from 2D to 1D as Determinant approaches 0", fontsize=16)
    plt.tight_layout()
    plt.show()

# シミュレーション実行
simulate_collapsing_space(steps=5)
```

__結果__

実行の結果を並べてみました。
行列式の値が小さくなるにつれて、ベクトルがつぶれていく様子が確認できます。
という感じで行列式は、行列になったベクトルが成す大きさを示します。


<img src="image/12_determinant/1771811351494.png" width="700" style="display: block; margin: 0 auto;">

<img src="image/12_determinant/1771811368785.png" width="700" style="display: block; margin: 0 auto;">

<img src="image/12_determinant/1771811387389.png" width="700" style="display: block; margin: 0 auto;">


### 5. 余因子行列

**余因子行列（Cofactor Matrix / Adjunct Matrix）** は、一言で言えば **「逆行列を作り出すための、各成分の『責任分担リスト』」** のようなものです。

行列式が「空間全体の拡大率」を表すのに対し、余因子行列は「特定の成分を除いたときに、残りの部分がどれだけの重み（面積・体積）を持っているか」を集めたものです。

__1. 余因子（Cofactor）とは何か？__

行列 $A$ のある成分 $a_{ij}$ に対する余因子とは、次のように定義されます。

> **「その成分がいる行と列をバッサリ消して、残った行列の行列式に、場所に応じた符号（ $\pm$ ）をつけたもの」**

__幾何学的なイメージ__

3次元行列で考えてみましょう。ある成分の余因子を求めることは、 **「その成分が担当する軸方向の情報を消したときに、残りの2軸が作る面の面積（拡大率）がいくらになるか」** を計算していることに相当します。

__2. 余因子行列の正体：逆行列の「部品」__

余因子をすべての成分について計算し、それを並べて**転置**したものを **余因子行列（Adjugate Matrix, $\text{adj}(A)$）** と呼びます。

この行列には、魔法のような性質があります。元の行列 $A$ と余因子行列を掛け合わせると、必ず「行列式を対角線に並べた行列」になります。

$$A \cdot \text{adj}(A) = \det(A) I$$

これを利用すると、有名な**逆行列の公式**が導かれます。

$$A^{-1} = \frac{1}{\det(A)} \text{adj}(A)$$

> **つまり、余因子行列とは：**
> 行列式（全体の拡大率）で割る前の、 **「逆行列の本体部分」** のことです。

__3. なぜ「余因子」が必要なのか？__

__① 逆行列を「公式」として扱える__

数値計算（掃き出し法）ではなく、文字式として逆行列を表現したい場合に不可欠です。

__② 各成分の「影響力」がわかる__

余因子行列の成分を見ることで、「元の行列のどの部分を少し変えると、逆変換にどう影響するか」という感度分析のような視点が得られます。

__③ 余因子展開__

行列式を計算する際、1つの行や列に注目して「成分 $\times$ 余因子」を足し合わせることで、大きな行列を小さな行列の計算に分解できます。

__4. 2次正方行列での具体例（一番馴染みがある形）__

みなさんがよく知る「2次行列の逆行列の公式」を余因子行列の視点で見てみましょう。

$$A = \begin{pmatrix} a & b \\ c & d \end{pmatrix} \implies \text{adj}(A) = \begin{pmatrix} d & -b \\ -c & a \end{pmatrix}$$

1. **対角成分 ($a, d$) を入れ替える：** これが余因子の計算結果です。
2. **符号を変える：** 場所による符号 ($\pm$) の調整です。
3. **$\det(A)$で割る：** これで逆行列の完成です。




