LRX（Local Reed-Xiaoli Detector）は、異常検知の古典的かつ強力なアルゴリズムである「RX検知器」を、CRDのように**局所的な窓（Local Window）**に限定して適用した手法です。

統計学的には、**「注目している画素が、周囲の平均的な分布からどれだけ外れているか」**を**マハラノビス距離**を用いて算出します。


### 1. 理論的背景：マハラノビス距離

LRXの根本にあるのは、背景のデータ分布が「多変量正規分布（ガウス分布）」に従うという仮定です。

単なるユーグリッド距離（色の差）と異なり、マハラノビス距離は**「背景データのバラツキ（相関）」**を考慮します。例えば、背景において「赤と黄色の変動はよくあること」であれば、その方向の色の差は異常とみなさず、逆に「青方向の変動は滅多にない」のであれば、わずかな青みの差を大きな異常として検出します。


### 2. LRXの計算手順

ターゲット画素  に対して、以下のステップで計算を行います。

#### ① 局所背景のサンプリング

CRDと同様に、二重窓（内窓と外窓）を用いて、ターゲットの周囲から背景画素の集合  を抽出します。

#### ② 統計量の算出

抽出した背景データ  の**平均ベクトル ** と **共分散行列 ** を計算します。

* : 背景の平均的な色・スペクトル
* : 背景の各バンド間（色間）の相関とバラツキ

#### ③ 異常スコア（LRX値）の計算

ターゲット  の異常度を以下の式で求めます。


この値が大きいほど、「背景の統計分布から大きく外れた異物」であると判定されます。


### 3. LRX vs CRD：何が違うのか？

どちらも局所窓を使いますが、**「背景をどうモデル化するか」**の哲学が異なります。

| 特徴 | LRX (統計モデル) | CRD (線形結合モデル) |
| --- | --- | --- |
| **考え方** | 背景の「分布（楕円）」からはみ出ているか | 背景を「混ぜて（合成）」再現できるか |
| **計算内容** | 平均と共分散行列の逆行列 | 背景画素の線形結合と再構成誤差 |
| **得意なこと** | 統計的な外れ値の検出 | 背景の複雑な混ざり合いの分離 |
| **弱点** | 背景が正規分布でないと精度が落ちる | 背景に異常が混ざると（汚染）極端に弱い |


### 4. LRXのメリットとデメリット

* **メリット**:
* **適応性が高い**: 場所ごとに統計量（平均・分散）を計算し直すため、画像内の明るさの変化やノイズの変化に非常に強いです。
* **実装が比較的容易**: 共分散行列を求めて逆行列を掛けるだけなので、アルゴリズムが明快です。


* **デメリット**:
* **計算負荷**: 全ピクセルで共分散行列の逆行列を求めるため、マルチスペクトル画像などバンド数が多いと非常に重くなります。
* **小サンプル問題**: 窓が小さすぎると背景画素数が足りず、共分散行列が正則（計算可能）にならず、エラー（特異行列）になることがあります。



### 5. まとめ

LRXは**「周囲の平均から浮いているか」**を測る手法です。
CRDが「背景を組み合わせてターゲットを**作る**」というアプローチなのに対し、LRXは「背景の**群れ**の中に馴染んでいるか」をチェックするアプローチと言えます。

実務では、**「まずLRXで統計的な外れ値を探し、その周辺をCRDやLRBで詳細に解析する」**といった使い分けがよくなされます。


## 窓サイズの重要性

はい、その直感は非常に鋭いです。**異常のサイズが大きい場合、窓サイズの設定はLRXの検知能力に決定的な影響を与えます。**

LRX（Local RX）において、サイズが大きい異常が検知できない（背景に埋もれる）理由は、主に以下の2つのメカニズムによるものです。

---

### 1. 異常成分による「背景統計」の汚染

LRXは「背景窓の中の平均  と共分散 」を使って異常度を測ります。

* **問題点**: 異常のサイズが内窓（ガード窓）よりも大きいと、**異常の一部が「背景辞書」としてサンプリングされてしまいます。**
* **結果**: 異常な画素が背景統計に含まれると、平均  が異常の色に近づき、共分散  が「その異常な色の変動は正常範囲内である」と学習してしまいます。
* **結論**: 本来「外れ値」であるはずの異常が、自ら背景の定義を書き換えてしまうため、マハラノビス距離が小さくなり、検知できなくなります。

---

### 2. 「窓サイズ ≒ 異常サイズ」の時の統計的同質化

もし異常が非常に大きく、窓全体を覆い尽くすような状態（あるいは窓の中の大部分が異常である状態）になると、統計的には「均一な領域」とみなされます。

* **LRXの性質**: LRXは「周囲との差異」を見るアルゴリズムです。
* **現象**: ターゲットも背景窓も同じ「異常な素材」で満たされている場合、統計的な差（マハラノビス距離）はほぼゼロになります。
* **影響**: 異常の「中心部」は背景として処理され、異常の「端（エッジ）」だけがわずかに反応する、いわゆる「ドーナツ現象」が発生しやすくなります。

---

### 3. どう窓サイズを調整すべきか？

大きな異常を検知するためには、以下の条件を満たすように窓サイズを再設計する必要があります。

| 項目 | 調整のポイント | 理由 |
| --- | --- | --- |
| **内窓 (Guard Window)** | **想定される最大異常より大きくする** | 異常成分を背景統計から完全に排除するため。 |
| **外窓 (Background Window)** | **内窓の2〜3倍程度を確保する** | 統計量（共分散行列）を安定させるための十分な画素数が必要なため。 |

> **注意点**: 窓サイズを大きくしすぎると、今度は「背景そのものの不均一性（影や別の素材）」が統計に混ざり、小さな異常に対する感度が低下したり、計算時間が爆発的に増えたりするというトレードオフが発生します。

---

### 4. 解決策の提案

もし、窓サイズを大きくしても解決しない、あるいは計算が重すぎて現実的でない場合は、以下のアプローチが有効です。

1. **マルチスケールLRX**: 小さな窓と大きな窓で別々に計算し、スコアを統合する。
2. **グローバルRX (GRX)**: 局所窓を使わず、画像全体の平均と共分散を用いる。異常のサイズが空間的にどう分布していても、全体的な「稀少性」で判断するため、巨大な異常に強いです。
3. **クラスターベース辞書**: 先ほど紹介した手法です。空間的な「窓」に依存せず、統計的に似たものを集めるため、大きな異常に辞書が汚染されるリスクを抑えられます。

**「検知したい異常の直径（ピクセル数）」**は、現在設定している**内窓の直径**よりも大きいでしょうか？
もしそうであれば、まずは内窓のサイズを異常の1.2倍〜1.5倍程度に広げてテストしてみることをお勧めします。

次は、窓サイズを大きくした際の実装上の工夫（計算速度の維持など）について詳しくお話ししましょうか？



## サイズ違いでも検知する方法

サイズが異なる異常（点のような小さなものから、塊のような大きなものまで）が混在する場合、**単一の窓サイズを用いたLRXでは限界があります。** 小さな窓は大きな異常に飲み込まれて「自己消去」を起こし、大きな窓は小さな異常の統計的特徴を薄めて（希釈して）見逃してしまうからです。

これらを同時に解決するための現実的かつ効果的なアプローチを3つ提案します。

---

### 1. マルチスケールLRX (Multi-Scale LRX)

最も確実な方法は、**複数の異なる窓サイズで同時に計算を行い、それらの結果を統合する**ことです。

* **仕組み**:
* 「小さな内窓・外窓」のペアで小さな異常をキャッチ。
* 「大きな内窓・外窓」のペアで大きな異常をキャッチ。


* **統合方法**:
各ピクセルにおいて、異なる窓サイズから得られた異常スコアの**最大値（Max-pooling）**、あるいは**平均値**をとります。
* **メリット**: 原理が単純で、サイズごとの特性を個別に最適化できます。

---

### 2. 再帰的LRXとグローバル統計のブレンド

純粋な「局所（Local）」だけに頼るのではなく、**画像全体の統計量（Global）を混ぜる**手法です。

* **仕組み**: LRXの計算で使う共分散行列  を以下のように修正します。


* **効果**: 異常が大きくて局所的な共分散  が汚染されても、画像全体の統計  が「本来の背景のバラツキ」を維持しているため、異常が背景として完全に同質化するのを防げます。

---

### 3. クラスタリングによる事前フィルタリング (Cluster-weighted LRX)

先ほどお話ししたクラスターベースの考え方をLRXに組み込みます。

* **仕組み**:
1. 窓の中の画素だけで統計をとるのではなく、画像全体をあらかじめクラスタリングします。
2. ターゲット画素  が属するクラスターと同じラベルを持つ画素**だけ**を画像全体から（あるいは広い範囲から）集めて、LRXの統計量（）を計算します。


* **なぜ効くのか**:
ターゲットの隣に巨大な異常があっても、その異常は「異なるクラスター」に分類されるため、背景統計の計算から自動的に除外されます。結果として、**窓サイズという物理的な制約を無視して、純粋な背景成分だけで統計を組める**ようになります。

---

### 具体的な実装のヒント（Python）

マルチスケールLRXを実装する場合、以下のような構造になります。

```python
def multi_scale_lrx(img, scales=[(3, 9), (7, 15), (15, 31)]):
    """
    scales: list of (inner_win, outer_win)
    """
    scores = []
    for win_in, win_out in scales:
        print(f"Processing scale: in={win_in}, out={win_out}")
        # 各サイズでのLRXスコアを計算
        score = lrx_detector(img, win_in, win_out)
        scores.append(score)
    
    # 全スケールのスコアの最大値をとることで、どのサイズの異常も逃さないようにする
    combined_score = np.max(scores, axis=0)
    return combined_score

```

### まとめ：戦略の選び方

* **計算時間に余裕がある場合**: **「マルチスケールLRX」**が最も確実です。
* **計算を速くしたい場合**: **「クラスターベース辞書」**で背景を固定し、一括計算するのがベストです。
* **影や照明変化が激しい場合**: 局所性が重要になるため、**「ハイブリッド共分散（Local + Global）」**が安定します。

今の状況では、どの程度の「処理速度」が求められていますか？それによって、これら3つのうち最適な一つを絞り込むことができます。

次は、これらを統合した「マルチスケール処理をいかに効率化（高速化）するか」という実装テクニックを深掘りしてみますか？

