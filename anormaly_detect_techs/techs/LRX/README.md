LRX（Local Reed-Xiaoli Detector）は、異常検知の古典的かつ強力なアルゴリズムである「RX検知器」を、CRDのように**局所的な窓（Local Window）**に限定して適用した手法です。

統計学的には、**「注目している画素が、周囲の平均的な分布からどれだけ外れているか」**を**マハラノビス距離**を用いて算出します。


### 1. 理論的背景：マハラノビス距離

LRXの根本にあるのは、背景のデータ分布が「多変量正規分布（ガウス分布）」に従うという仮定です。

単なるユーグリッド距離（色の差）と異なり、マハラノビス距離は**「背景データのバラツキ（相関）」**を考慮します。例えば、背景において「赤と黄色の変動はよくあること」であれば、その方向の色の差は異常とみなさず、逆に「青方向の変動は滅多にない」のであれば、わずかな青みの差を大きな異常として検出します。


### 2. LRXの計算手順

ターゲット画素  に対して、以下のステップで計算を行います。

#### ① 局所背景のサンプリング

CRDと同様に、二重窓（内窓と外窓）を用いて、ターゲットの周囲から背景画素の集合  を抽出します。

#### ② 統計量の算出

抽出した背景データ  の**平均ベクトル ** と **共分散行列 ** を計算します。

* : 背景の平均的な色・スペクトル
* : 背景の各バンド間（色間）の相関とバラツキ

#### ③ 異常スコア（LRX値）の計算

ターゲット  の異常度を以下の式で求めます。


この値が大きいほど、「背景の統計分布から大きく外れた異物」であると判定されます。


### 3. LRX vs CRD：何が違うのか？

どちらも局所窓を使いますが、**「背景をどうモデル化するか」**の哲学が異なります。

| 特徴 | LRX (統計モデル) | CRD (線形結合モデル) |
| --- | --- | --- |
| **考え方** | 背景の「分布（楕円）」からはみ出ているか | 背景を「混ぜて（合成）」再現できるか |
| **計算内容** | 平均と共分散行列の逆行列 | 背景画素の線形結合と再構成誤差 |
| **得意なこと** | 統計的な外れ値の検出 | 背景の複雑な混ざり合いの分離 |
| **弱点** | 背景が正規分布でないと精度が落ちる | 背景に異常が混ざると（汚染）極端に弱い |


### 4. LRXのメリットとデメリット

* **メリット**:
* **適応性が高い**: 場所ごとに統計量（平均・分散）を計算し直すため、画像内の明るさの変化やノイズの変化に非常に強いです。
* **実装が比較的容易**: 共分散行列を求めて逆行列を掛けるだけなので、アルゴリズムが明快です。


* **デメリット**:
* **計算負荷**: 全ピクセルで共分散行列の逆行列を求めるため、マルチスペクトル画像などバンド数が多いと非常に重くなります。
* **小サンプル問題**: 窓が小さすぎると背景画素数が足りず、共分散行列が正則（計算可能）にならず、エラー（特異行列）になることがあります。



### 5. まとめ

LRXは**「周囲の平均から浮いているか」**を測る手法です。
CRDが「背景を組み合わせてターゲットを**作る**」というアプローチなのに対し、LRXは「背景の**群れ**の中に馴染んでいるか」をチェックするアプローチと言えます。

実務では、**「まずLRXで統計的な外れ値を探し、その周辺をCRDやLRBで詳細に解析する」**といった使い分けがよくなされます。


## 窓サイズの重要性

はい、その直感は非常に鋭いです。**異常のサイズが大きい場合、窓サイズの設定はLRXの検知能力に決定的な影響を与えます。**

LRX（Local RX）において、サイズが大きい異常が検知できない（背景に埋もれる）理由は、主に以下の2つのメカニズムによるものです。

---

### 1. 異常成分による「背景統計」の汚染

LRXは「背景窓の中の平均  と共分散 」を使って異常度を測ります。

* **問題点**: 異常のサイズが内窓（ガード窓）よりも大きいと、**異常の一部が「背景辞書」としてサンプリングされてしまいます。**
* **結果**: 異常な画素が背景統計に含まれると、平均  が異常の色に近づき、共分散  が「その異常な色の変動は正常範囲内である」と学習してしまいます。
* **結論**: 本来「外れ値」であるはずの異常が、自ら背景の定義を書き換えてしまうため、マハラノビス距離が小さくなり、検知できなくなります。

---

### 2. 「窓サイズ ≒ 異常サイズ」の時の統計的同質化

もし異常が非常に大きく、窓全体を覆い尽くすような状態（あるいは窓の中の大部分が異常である状態）になると、統計的には「均一な領域」とみなされます。

* **LRXの性質**: LRXは「周囲との差異」を見るアルゴリズムです。
* **現象**: ターゲットも背景窓も同じ「異常な素材」で満たされている場合、統計的な差（マハラノビス距離）はほぼゼロになります。
* **影響**: 異常の「中心部」は背景として処理され、異常の「端（エッジ）」だけがわずかに反応する、いわゆる「ドーナツ現象」が発生しやすくなります。

---

### 3. どう窓サイズを調整すべきか？

大きな異常を検知するためには、以下の条件を満たすように窓サイズを再設計する必要があります。

| 項目 | 調整のポイント | 理由 |
| --- | --- | --- |
| **内窓 (Guard Window)** | **想定される最大異常より大きくする** | 異常成分を背景統計から完全に排除するため。 |
| **外窓 (Background Window)** | **内窓の2〜3倍程度を確保する** | 統計量（共分散行列）を安定させるための十分な画素数が必要なため。 |

> **注意点**: 窓サイズを大きくしすぎると、今度は「背景そのものの不均一性（影や別の素材）」が統計に混ざり、小さな異常に対する感度が低下したり、計算時間が爆発的に増えたりするというトレードオフが発生します。

---

### 4. 解決策の提案

もし、窓サイズを大きくしても解決しない、あるいは計算が重すぎて現実的でない場合は、以下のアプローチが有効です。

1. **マルチスケールLRX**: 小さな窓と大きな窓で別々に計算し、スコアを統合する。
2. **グローバルRX (GRX)**: 局所窓を使わず、画像全体の平均と共分散を用いる。異常のサイズが空間的にどう分布していても、全体的な「稀少性」で判断するため、巨大な異常に強いです。
3. **クラスターベース辞書**: 先ほど紹介した手法です。空間的な「窓」に依存せず、統計的に似たものを集めるため、大きな異常に辞書が汚染されるリスクを抑えられます。

**「検知したい異常の直径（ピクセル数）」**は、現在設定している**内窓の直径**よりも大きいでしょうか？
もしそうであれば、まずは内窓のサイズを異常の1.2倍〜1.5倍程度に広げてテストしてみることをお勧めします。

次は、窓サイズを大きくした際の実装上の工夫（計算速度の維持など）について詳しくお話ししましょうか？



## サイズ違いでも検知する方法

サイズが異なる異常（点のような小さなものから、塊のような大きなものまで）が混在する場合、**単一の窓サイズを用いたLRXでは限界があります。** 小さな窓は大きな異常に飲み込まれて「自己消去」を起こし、大きな窓は小さな異常の統計的特徴を薄めて（希釈して）見逃してしまうからです。

これらを同時に解決するための現実的かつ効果的なアプローチを3つ提案します。

---

### 1. マルチスケールLRX (Multi-Scale LRX)

最も確実な方法は、**複数の異なる窓サイズで同時に計算を行い、それらの結果を統合する**ことです。

* **仕組み**:
* 「小さな内窓・外窓」のペアで小さな異常をキャッチ。
* 「大きな内窓・外窓」のペアで大きな異常をキャッチ。


* **統合方法**:
各ピクセルにおいて、異なる窓サイズから得られた異常スコアの**最大値（Max-pooling）**、あるいは**平均値**をとります。
* **メリット**: 原理が単純で、サイズごとの特性を個別に最適化できます。

---

### 2. 再帰的LRXとグローバル統計のブレンド

純粋な「局所（Local）」だけに頼るのではなく、**画像全体の統計量（Global）を混ぜる**手法です。

* **仕組み**: LRXの計算で使う共分散行列  を以下のように修正します。


* **効果**: 異常が大きくて局所的な共分散  が汚染されても、画像全体の統計  が「本来の背景のバラツキ」を維持しているため、異常が背景として完全に同質化するのを防げます。

---

### 3. クラスタリングによる事前フィルタリング (Cluster-weighted LRX)

先ほどお話ししたクラスターベースの考え方をLRXに組み込みます。

* **仕組み**:
1. 窓の中の画素だけで統計をとるのではなく、画像全体をあらかじめクラスタリングします。
2. ターゲット画素  が属するクラスターと同じラベルを持つ画素**だけ**を画像全体から（あるいは広い範囲から）集めて、LRXの統計量（）を計算します。


* **なぜ効くのか**:
ターゲットの隣に巨大な異常があっても、その異常は「異なるクラスター」に分類されるため、背景統計の計算から自動的に除外されます。結果として、**窓サイズという物理的な制約を無視して、純粋な背景成分だけで統計を組める**ようになります。

---

### 具体的な実装のヒント（Python）

マルチスケールLRXを実装する場合、以下のような構造になります。

```python
def multi_scale_lrx(img, scales=[(3, 9), (7, 15), (15, 31)]):
    """
    scales: list of (inner_win, outer_win)
    """
    scores = []
    for win_in, win_out in scales:
        print(f"Processing scale: in={win_in}, out={win_out}")
        # 各サイズでのLRXスコアを計算
        score = lrx_detector(img, win_in, win_out)
        scores.append(score)
    
    # 全スケールのスコアの最大値をとることで、どのサイズの異常も逃さないようにする
    combined_score = np.max(scores, axis=0)
    return combined_score

```

### まとめ：戦略の選び方

* **計算時間に余裕がある場合**: **「マルチスケールLRX」**が最も確実です。
* **計算を速くしたい場合**: **「クラスターベース辞書」**で背景を固定し、一括計算するのがベストです。
* **影や照明変化が激しい場合**: 局所性が重要になるため、**「ハイブリッド共分散（Local + Global）」**が安定します。

今の状況では、どの程度の「処理速度」が求められていますか？それによって、これら3つのうち最適な一つを絞り込むことができます。

## LRXの検知力不足

LRX（Local RX）で期待した異常が検知できない場合、アルゴリズムの理論的な前提と、実際のデータの「ズレ」が原因であることがほとんどです。

考えられる主な原因を、**「窓の設定」「背景の性質」「異常の性質」**の3つの視点から整理しました。

---

### 1. 窓サイズ（Window Size）のミスマッチ

これが最も多い原因です。LRXの検出力は内窓（ガード窓）と外窓（背景窓）のサイズに完全に依存します。

* **内窓が小さすぎる**: ターゲットとする異常が内窓からはみ出し、外窓（背景エリア）に混入していませんか？異常が背景統計に混ざると、その異常な色が「正常」として学習され、マハラノビス距離が激減します（**自己消去現象**）。
* **外窓が小さすぎる**: 共分散行列を計算するためのサンプル数が不足し、統計的に不安定になっています。一般に、外窓の画素数はバンド数（次元数）の数倍以上必要です。

---

### 2. 背景の「不均一性」と「非正規性」

LRXは、背景が**「単一の素材で、かつ正規分布（ガウス分布）に従う」**ことを前提としています。

* **背景に複数の素材がある**: 窓の中に「土」と「草」と「コンクリート」が混ざっている場合、平均  はそれらの中間値になり、共分散  は非常に大きくなります。
* **影響**: 異常がその広いバラツキの中に隠れてしまい、「珍しいもの」として認識されなくなります。これを**「統計的な希釈（Dilution）」**と呼びます。
* **対策**: 窓を小さくして背景を均一にするか、CRDのように「組み合わせ」で考える手法への変更を検討してください。

---

### 3. 異常と背景の「相関（色の似方）」

異常が背景と明らかに色が違っていても、**「色の並び方（相関）」**が背景と同じだとLRXは反応しません。

* **マハラノビス距離の落とし穴**: LRXは「背景のバラツキが激しい方向」の変化には鈍感です。もし異常の変化が、背景がもともと持っている色の変動（例：影の濃淡やセンサーノイズの方向）と同じ方向であれば、距離は伸びません。
* **対策**: PCA（主成分分析）で背景の主要な変動成分を取り除いてからLRXをかける、あるいは非線形な差異を捉える**KLRX（Kernel RX）**が有効です。

---

### 4. センサーノイズと「共分散行列の特異性」

ハイパースペクトルデータなどでバンド数が多い場合、共分散行列が正しく計算できていない可能性があります。

* **低ランク問題**: 特定のバンド間で相関が強すぎると、逆行列の計算が数値的に不安定になり、スコアがノイズだらけになるか、逆に全く反応しなくなります。
* **対策**: 計算時に対角成分に微小値を加える（正則化）か、事前に次元圧縮を行う必要があります。

---

### 原因を特定するための「チェックリスト」

以下の質問への答えで、次に打つべき手が見えてきます。

1. **異常のサイズ（ピクセル数）は？**
* 内窓のサイズよりも大きいなら、**内窓を広げる**必要があります。


2. **背景は複雑（ガチャガチャしている）か？**
* YESなら、統計（LRX）ではなく**再構成（CRD）**の方が向いています。


3. **スコアマップはどう見えるか？**
* 全体的に真っ白（ノイズだらけ）なら、**正則化不足**か**外窓が小さすぎ**ます。
* 異常の「縁（フチ）」だけが光っているなら、**内窓が小さすぎ**て自己消去が起きています。


そのご認識、**「半分は正解ですが、もう半分にLRX特有の泣き所」**があります。

非常に鋭い着眼点ですので、LRXの性質を「草原と道路」の例で整理してみましょう。

---

### 1. 「ローカルな分散で説明できない変化」への感度

ここまでは**大正解**です。
LRXは、外窓（背景）の画素たちが作る「色の広がり（共分散）」という物差しでターゲットを測ります。

* **草原の中の小さな石**: 草原の「緑のバリエーション」という物差しでは、「グレー」という色は想定外の方向に突き出た変化です。そのため、マハラノビス距離が大きくなり、鮮やかに検知されます。

---

### 2. 「道路の境界」が検知されやすいか？（ここが泣き所）

ここについては、**「検知されやすい（＝誤報になりやすい）」**というのが実態です。

LRXにとって、道路の境界（エッジ）は非常にストレスフルな場所です。理由は以下の通りです。

#### ① 背景の「混ざり（不均一性）」によるボケ

窓が境界線の上に乗ると、外窓の中に「草（緑）」と「アスファルト（グレー）」が両方入ってしまいます。

* **影響**: 背景の分散（物差し）が、「緑からグレーまで全部OK」という非常に長くてガバガバな形に伸びてしまいます。
* **結果**: 本来異常であるはずのグレーの画素が、この伸び切った物差しの「想定内」に収まってしまい、**検知力が逆に低下する（異常が背景に埋もれる）**ことがあります。

#### ② 「平均」からのズレによる過剰反応

一方で、窓内の「平均色」は「くすんだ緑（緑とグレーの中間）」になります。

* **現象**: ターゲットが「純粋なグレー（道路）」や「鮮やかな緑（草）」の場合、どちらも「中間色の平均」からは遠いため、**境界線全体が異常スコアとして光ってしまいます。**

---

### 3. LRXの認識のまとめ

ご認識の通り、LRXは**「周囲の多数派のルールに従わないもの」**を見つけるのが得意です。しかし、道路の境界のような「二つのルールが混ざる場所」では、以下のジレンマが発生します。

| 場所 | 現象 | 結果 |
| --- | --- | --- |
| **均一な草原の中** | 背景の物差しが「緑」に特化している | 小さな異物を**きっちり検知**できる。 |
| **道路の境界（エッジ）** | 背景の物差しが「緑とグレー」に引き伸ばされる | 境界線そのものが**「異常な線」として誤検知**される。 |

---

### どうすれば「道路」を無視して「異常」だけを探せるか？

もし「道路の境界線が光ってしまうのが邪魔だ（＝本当の異常が見えにくい）」と感じているなら、以下の対策が考えられます。

1. **CRD（協調表現）を使う**:
CRDは「周囲の素材の組み合わせ」で考えます。「道路の境界」であれば、周囲に「草」と「道路」の素材が両方あるため、それらを組み合わせればターゲットを完璧に説明できてしまいます。結果として、**道路の境界での誤報が劇的に減ります。**
2. **GAD（グラフベース）を使う**:
グラフ理論なら、「草の島」と「道路の島」を繋ぐ細いエッジとして境界を認識するため、そこを「孤立した異常」とは見なしにくくなります。

### 結論

「草原に道路がある地形」において、LRXは**道路の縁（ふち）を「異常」として派手に検出してしまいます。** もしそれが目的（道路の抽出）なら正解ですが、もし「道路のそばに落ちている不審物」を探したいのであれば、LRXにとっては非常に過酷な環境と言えます。

LRXの枠組みを維持しつつ、道路の境界（エッジ）での誤報を抑える「発展的な手法」はいくつか存在します。

LRXが境界線で誤報を出す最大の原因は、**「窓の中に異なる性質の背景が混ざり、統計（平均・分散）が破綻すること」**です。これを解決するためのアプローチを3つ紹介します。

---

### 1. セグメンテーション・ベース RX (Segmentation-based RX)

窓を「機械的な四角形」ではなく、**「意味のある塊」**に変える手法です。

* **仕組み**: RXをかける前に、画像全体をスーパーピクセル（SLICなど）やセグメンテーションで似た色の領域に分割します。
* **課題への対応**: 外窓（背景統計）を計算する際、**「ターゲットと同じ領域に属する画素だけ」**をサンプリングします。
* **効果**: 境界線上にターゲットがある場合、物差しを作るための画素を「道路側」か「草原側」のどちらか一方に限定できるため、統計が混ざらず、境界線での過剰反応を劇的に抑えられます。

---

### 2. 重み付き RX (Weighted RX / W-RX)

外窓内の全ての画素を平等に扱うのではなく、**「ターゲットと似ている画素」を優先して物差しを作る**手法です。

* **仕組み**: 各背景画素に対して、ターゲットとのスペクトル距離に応じた重み（ガウスカーネルなど）を与え、**重み付き共分散行列**を計算します。
* **課題への対応**: 境界線に窓がかかっても、ターゲットが「道路」なら「道路の画素」の重みが大きくなり、統計が道路に最適化されます。
* **効果**: 異質な背景（草原）の影響を計算から排除できるため、境界線が「異常」として浮き上がりにくくなります。

---

### 3. 多重仮説・部分空間 RX (Subspace RX / Orthogonal Subspace Projection)

背景を「広がり」ではなく**「成分（ベクトル）」**として捉える手法です。

* **仕組み**: 外窓内の画素を主成分分析（PCA）し、主要な背景成分（草原の成分、道路の成分）を「背景部分空間」として定義します。
* **課題への対応**: ターゲットから、この「背景部分空間」へ投影した成分を差し引きます。
* **効果**: ターゲットが「草原」や「道路」であれば、背景成分として除去されます。そこに属さない**「草原でも道路でもない成分」**だけが残るため、境界線は消え、真の異常だけが強調されます。

---

### 手法の比較と推奨

| 手法 | 実装難易度 | 境界線の抑制効果 | 特徴 |
| --- | --- | --- | --- |
| **1. Segmentation-based** | 中 | **最強** | 境界がハッキリしている地形に最適。 |
| **2. Weighted RX** | 低 | 中 | 局所的な色の変化が緩やかな場合に有効。 |
| **3. Subspace RX** | 高 | 高 | 理論的に最も美しく、ノイズにも強い。 |

### まず試すべき一歩： 「重み付き RX」の実装

最も手軽に試せるのは、前述の **Weighted RX** です。
現在のLRXのコードにおいて、共分散行列を求める際に `np.cov` を使うのではなく、ターゲットとの色の差が小さい画素ほど大きく寄与するような重み付き計算に変更するだけで、境界線の光り方が抑えられるはずです。

この「重み付き共分散」を用いた計算ロジックの実装例、あるいはセグメンテーション（領域分割）と組み合わせる具体的なフロー、どちらに興味がありますか？

「境界線を消す」という目的であれば、**セグメンテーションを前処理に入れる**のが最も確実な特効薬になります。


